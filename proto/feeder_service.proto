syntax = "proto3";
import "fanfic.proto";
import "fandom.proto";
import "filter.proto";
import "favlist.proto";

package ProtoSpace;

message ControlInfo{
    string user_token       = 1;
}
message ResponseInfo{
    bool is_valid                = 1;
    bool has_usertoken_error     = 2;
    bool data_size_limit_reached = 3;
    bool token_in_use            = 4;
}

message TagsToken{
    repeated int32 all_tags       = 1;
    repeated int32 searched_tags  = 2;
}


message IgnoredFandomsToken{
    repeated int32 fandom_ids           = 1;
    repeated bool  ignore_crossovers    = 2;
}

message RecommendationListDataToken
{
    repeated int32 list_of_fics                     = 1;
    repeated int32 list_of_matches                  = 2;
}

message ScoreListDataToken
{ 
    repeated int32 list_of_fics                     = 1;
    repeated int32 list_of_scores                   = 2;
}

message UserData{
    TagsToken user_tags                              = 1;
    IgnoredFandomsToken ignored_fandoms              = 2;
    RecommendationListDataToken recommendation_list  = 3;
    ScoreListDataToken scores_list                   = 4;
}

message SearchTask
{
    ControlInfo controls    = 1;
    Filter filter           = 2;
    UserData user_data      = 3;
}

message SearchResponse{
    repeated Fanfic fanfics               = 1;
    ResponseInfo response_info            = 2;
}
message SearchByFFNIDTask
{    enum IDType{
        ffn         = 0;
        db          = 1;
    };
    ControlInfo controls    = 1;
    int32 id                = 2;
    IDType id_type          = 3;
}

message SearchByFFNIDResponse{
    bool success                          = 1;
    Fanfic fanfic                         = 2;
    ResponseInfo response_info            = 3;
}


message SyncFandomListTask{
    ControlInfo controls    = 1;
    int32 last_fandom_id    = 2;
}

message SyncFandomListResponse{
    bool needs_update       = 1;
    repeated Fandom fandoms = 2;
    ResponseInfo response_info            = 3;
}

message FicCountTask{
    ControlInfo controls    = 1;
    Filter filter           = 2;
    UserData user_data      = 3;
}

message FicCountResponse{
    int32 fic_count = 1;
    ResponseInfo response_info    = 2;
}


message SiteIDPack{
    repeated int32 db_ids =  1;
    repeated int32 ffn_ids = 2;
    repeated int32 ao3_ids = 3;
    repeated int32 sb_ids  = 4;
    repeated int32 sv_ids  = 5;
}
message RecommendationBreakdown{
    int32 id              = 1;
    int32 counts_common   = 2;
    int32 counts_uncommon = 3;
    int32 counts_rare     = 4;
    int32 counts_unique   = 5;
    int32 votes_common    = 6;
    int32 votes_uncommon  = 7;
    int32 votes_rare      = 8;
    int32 votes_unique    = 9;
}
message RecommendationListData{
    bool list_ready                             = 1;
    string list_name                            = 2;
    repeated int32 fic_ids                      = 3;
    repeated int32 fic_matches                  = 4;
                                                
    map<int32, int32> match_report              = 5;
    repeated RecommendationBreakdown breakdowns = 6;

    // these are internal ids
    // no conflict & harassment possibilities here
    repeated int32 author_ids                   = 7;
    repeated int32 purged                       = 8;
}
message NegativeTagsToken{
    repeated int32 basicNegatives       = 1;
    repeated int32 strongNegatives      = 2;
}

message RecListUserData{
    IgnoredFandomsToken ignored_fandoms = 1;
    NegativeTagsToken negative_feedback = 2;
    repeated int32 liked_authors        = 3;
}

message RecommendationListCreationRequest{
    ControlInfo controls                = 1;
    string list_name                    = 2;
    int32 min_fics_to_match             = 3;
    int32 max_unmatched_to_one_matched  = 4;
    int32 always_pick_at                = 5;
    SiteIDPack id_packs                 = 6;
    bool return_sources                 = 7;
    bool use_weighting                  = 8;
    RecListUserData user_data           = 9;
    int32 users_ffn_profile_id          = 10;
    bool use_mood_filtering             = 11;
}

message RecommendationListCreationResponse{
    string list_token           = 1;
    RecommendationListData list = 2;
    ResponseInfo response_info   = 3;
}

message RecommendationListFetchRequest{
    ControlInfo controls                = 1;
    string list_token                   = 2;
}

message RecommendationListFetchResponse{
    bool list_available              = 1;
    bool position_in_queue           = 2;
    RecommendationListData list_data = 3;
    ResponseInfo response_info       = 4;
}

message FicIdRequest{
    ControlInfo controls             = 1;
    SiteIDPack  ids                  = 2;
}

message FicIdResponse{
    bool success        = 1;
    SiteIDPack ids      = 2;
    ResponseInfo response_info        = 3;
}

message StatusRequest{
    ControlInfo controls        = 1;
}

message StatusResponse{
    bool   database_attached    = 1; // for when I need to switch symlinks
    string last_database_update = 2; // yyyyMMdd hhmm, currently not implemented
    string message_of_the_day   = 3;
    bool need_to_show_motd      = 4;
    int32 protocol_version      = 5; 
}

message FavListDetailsRequest{
    ControlInfo controls             = 1;
    SiteIDPack id_packs              = 2;
}

message FavListDetailsResponse{
    bool success                    = 1;
    FavListDetails details          = 2; 
    ResponseInfo response_info      = 3;
}

message AuthorsForFicsRequest{
    ControlInfo controls             = 1;
    SiteIDPack id_packs              = 2;
}

message AuthorsForFicsResponse{
    bool success                    = 1;
    repeated int32 fics             = 2; 
    repeated int32 authors          = 3; 
    ResponseInfo response_info      = 4;
    
}

message AuthorsForFicInReclistRequest{
    ControlInfo controls             = 1;
    int32 fic_id                     = 2;
    string author_list               = 3;
}

message AuthorsForFicInReclistResponse{
    bool success                    = 1;
    repeated int32 filtered_authors = 2; 
    ResponseInfo response_info      = 3;
}
message UserMatchRequest{
    ControlInfo controls             = 1;
    int32 source_user                = 2;
    repeated int32 user_fics         = 3;
    repeated int32 fandom_ignores    = 4;
    repeated int32 test_users        = 5;
}
message UserMatch{
    int32 user_id                  = 1;
    int32 ratio                    = 2; 
    int32 ratio_without_ignores    = 3;
    repeated int32 fic_id          = 4;
    repeated string fic_title      = 5;
}

message UserMatchResponse{
    bool success                    = 1;
    repeated UserMatch matches      = 2; 
    ResponseInfo response_info      = 3;
}

// will need to synchronize fandoms on app start somehow
// can't leave fandom information on user side
// because I dont want users to parse anything

// same thing for genres, probbaly better to receive the on launch


// RecommendationListsFandoms needs to be returned with recommendation list data
// I want to be able to display this to users ideally

service Feeder { 
    rpc GetStatus(StatusRequest) returns (StatusResponse) {}
    rpc Search(SearchTask) returns (SearchResponse) {}
    rpc SearchByFFNID(SearchByFFNIDTask) returns (SearchByFFNIDResponse) {}
    rpc GetFicCount(FicCountTask) returns (FicCountResponse) {}
    rpc SyncFandomList(SyncFandomListTask) returns (SyncFandomListResponse) {}
    rpc RecommendationListCreation(RecommendationListCreationRequest) returns (RecommendationListCreationResponse) {}
    rpc GetDBFicIDS(FicIdRequest) returns (FicIdResponse) {}
    rpc GetFFNFicIDS(FicIdRequest) returns (FicIdResponse) {}
    rpc GetFavListDetails(FavListDetailsRequest) returns (FavListDetailsResponse) {}
    rpc GetAuthorsForFicList(AuthorsForFicsRequest) returns (AuthorsForFicsResponse) {}
    rpc GetAuthorsFromRecListContainingFic(AuthorsForFicInReclistRequest) returns (AuthorsForFicInReclistResponse) {}
    rpc GetUserMatches(UserMatchRequest) returns (UserMatchResponse) {}
}
